
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>nengo_dl.converter &#8212; NengoDL 3.1.0 docs</title>
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:400,400i,600|Rajdhani:700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css" integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">
<link rel="stylesheet" href="https://www.nengo.ai/css/bootstrap.css" type="text/css">
<style>
  body .title-bar,
  body .documentation-source h1:after {
    background-color: #ff6600;
  }
</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-41658423-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-41658423-2');
</script>
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://unpkg.com/scrollreveal"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stickyfill/2.1.0/stickyfill.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
<!-- From basic/layout.html -->
<script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
  
  
<script src="../../_static/underscore.js"></script>
  
  
<script src="../../_static/doctools.js"></script>
  
  
<script src="../../_static/language_data.js"></script>
  
  
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
  
  
<script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  
<script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  </head><body class="bg-dark">

<header class="fixed-top header-top shadow-sm">
  <nav class="navbar navbar-expand-md navbar-light bg-white">
    <a class="navbar-brand" href="https://www.nengo.ai/">
      <img
        src="https://www.nengo.ai/design/_images/general-full-light.svg"
        alt="Nengo"
        class="logo"
      />
    </a>
    <button
      class="navbar-toggler"
      type="button"
      data-toggle="collapse"
      data-target="#navbar-collapse"
      aria-controls="navbar-collapse"
      aria-expanded="false"
      aria-label="Toggle navigation"
    >
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbar-collapse">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="https://www.nengo.ai/">What is Nengo?</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://www.nengo.ai/examples/">Examples</a>
        </li>
        <li class="nav-item dropdown active">
          <a
            class="nav-link dropdown-toggle"
            id="navbar-dropdown-docs"
            data-toggle="dropdown"
            aria-haspopup="true"
            aria-expanded="false"
            href="#"
            >Documentation</a
          >
          <div
            class="dropdown-menu shadow-lg border-0"
            aria-labelledby="navbar-dropdown-docs"
          >
            
            <a class="dropdown-item" href="https://www.nengo.ai/nengo/">Nengo Core</a>
            <a class="dropdown-item" href="https://github.com/nengo/nengo-gui/">Nengo GUI</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-dl/">Nengo DL</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-spa/">Nengo SPA</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-extras/">Nengo Extras</a>
            <a class="dropdown-item" href="https://arvoelke.github.io/nengolib-docs/">Nengolib</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-fpga/">Nengo FPGA</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-loihi/">Nengo Loihi</a>
            <a class="dropdown-item" href="https://github.com/nengo/nengo-ocl">Nengo OpenCL</a>
            <a class="dropdown-item" href="https://github.com/project-rig/nengo_spinnaker">Nengo SpiNNaker</a>
            <a class="dropdown-item" href="https://github.com/nengo/nengo-mpi">Nengo MPI</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/documentation/"
              >All documentation</a
            >
          </div>
        </li>
        <li class="nav-item dropdown">
          <a
            class="nav-link dropdown-toggle"
            id="navbar-dropdown-community"
            data-toggle="dropdown"
            aria-haspopup="true"
            aria-expanded="false"
            href="#"
            >Community</a
          >
          <div
            class="dropdown-menu shadow-lg border-0"
            aria-labelledby="navbar-dropdown-community"
          >
            <a class="dropdown-item" href="https://forum.nengo.ai">Forum</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/people/"
              >People</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/summer-school/"
              >Summer school</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/contributing/"
              >Contributing</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/publications/"
              >Publications</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/videos/"
              >Videos</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/conduct/"
              >Code of conduct</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/caa/">CAA</a>
          </div>
        </li>
        <li class="nav-item">
          <a
            class="nav-link btn btn-success btn-sm text-white"
            href="https://www.nengo.ai/getting-started/"
            >Getting started</a
          >
        </li>
      </ul>
    </div>
  </nav>
</header>
<div class="main-content gradient-top">
  <div class="container-fluid">
    <div class="row"><a class="toggle-sidenav d-block d-md-none" href="#"
  ><i class="icon-close fa fa-fw fa-arrow-left"></i
  ><i class="icon-open fa fa-fw fa-arrow-right"></i
></a>
<div role="complementary" class="sidenav col-4 col-xl-3 p-0 border-right">
  <h3 class="pt-5 px-5">
    <a href="../../index.html">
      <img
        class="img-fluid documentation-image"
        src="https://www.nengo.ai/design/_images/nengo-dl-full-light.svg"
        alt="NengoDL"
      />
    </a>
  </h3>
  
  <form class="px-5 pb-5 mb-0 mt-3 border-bottom">
    <div class="form-group">
      <label class="text-gray">Version:</label>
      <select class="custom-select" onchange="switchVersion(this);">
        
        
        <option value="../../../_modules/nengo_dl/converter.html">latest</option>
        
        
          
        <option selected>v3.1.0</option>
          
        
          
        <option value="../../../v3.0.0/_modules/nengo_dl/converter.html">
          v3.0.0
        </option>
          
        
          
        <option value="../../../v2.2.2/_modules/nengo_dl/converter.html">
          v2.2.2
        </option>
          
        
          
        <option value="../../../v2.2.1/_modules/nengo_dl/converter.html">
          v2.2.1
        </option>
          
        
          
        <option value="../../../v2.2.0/_modules/nengo_dl/converter.html">
          v2.2.0
        </option>
          
        
          
        <option value="../../../v2.1.1/_modules/nengo_dl/converter.html">
          v2.1.1
        </option>
          
        
          
        <option value="../../../v2.1.0/_modules/nengo_dl/converter.html">
          v2.1.0
        </option>
          
        
          
        <option value="../../../v2.0.0/_modules/nengo_dl/converter.html">
          v2.0.0
        </option>
          
        
          
        <option value="../../../v1.2.1/_modules/nengo_dl/converter.html">
          v1.2.1
        </option>
          
        
          
        <option value="../../../v1.2.0/_modules/nengo_dl/converter.html">
          v1.2.0
        </option>
          
        
          
        <option value="../../../v1.1.0/_modules/nengo_dl/converter.html">
          v1.1.0
        </option>
          
        
          
        <option value="../../../v1.0.0/_modules/nengo_dl/converter.html">
          v1.0.0
        </option>
          
        
          
        <option value="../../../v0.6.2/_modules/nengo_dl/converter.html">
          v0.6.2
        </option>
          
        
          
        <option value="../../../v0.6.1/_modules/nengo_dl/converter.html">
          v0.6.1
        </option>
          
        
          
        <option value="../../../v0.6.0/_modules/nengo_dl/converter.html">
          v0.6.0
        </option>
          
        
          
        <option value="../../../v0.5.2/_modules/nengo_dl/converter.html">
          v0.5.2
        </option>
          
        
          
        <option value="../../../v0.5.1/_modules/nengo_dl/converter.html">
          v0.5.1
        </option>
          
        
          
        <option value="../../../v0.5.0/_modules/nengo_dl/converter.html">
          v0.5.0
        </option>
          
        
          
        <option value="../../../v0.4.0/_modules/nengo_dl/converter.html">
          v0.4.0
        </option>
          
        
          
        <option value="../../../v0.3.1/_modules/nengo_dl/converter.html">
          v0.3.1
        </option>
          
        
          
        <option value="../../../v0.3.0/_modules/nengo_dl/converter.html">
          v0.3.0
        </option>
          
        
          
        <option value="../../../v0.2.0/_modules/nengo_dl/converter.html">
          v0.2.0
        </option>
          
        
      </select>
    </div>
  </form>
  
  <div class="p-5 toctree">
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user-guide.html">User guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Additional resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../project.html">Project information</a></li>
</ul>

  </div>
<form class="p-5 my-0 border-top" action="../../search.html" method="get">
  <div class="form-group form-group-single">
    <input type="text" name="q" class="form-control" placeholder="Search" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
    <button type="submit" class="btn btn-link">
      <img src="https://www.nengo.ai/img/icon-search.svg" alt="Go" />
    </button>
  </div>
</form></div>
      

      <div class="col-12 col-md-8 col-xl-9">
        <div class="container">
          <div class="row">
            <div class="col-10 offset-1 pb-5 documentation-source" role="main">
              
  <h1>Source code for nengo_dl.converter</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Tools for automatically converting a Keras model to a Nengo network.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">nengo</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.keras.layers</span> <span class="kn">import</span> <span class="n">BatchNormalization</span><span class="p">,</span> <span class="n">BatchNormalizationV2</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.util</span> <span class="kn">import</span> <span class="n">nest</span>

<span class="kn">from</span> <span class="nn">nengo_dl.config</span> <span class="kn">import</span> <span class="n">configure_settings</span>
<span class="kn">from</span> <span class="nn">nengo_dl.tensor_node</span> <span class="kn">import</span> <span class="n">Layer</span><span class="p">,</span> <span class="n">TensorNode</span>
<span class="kn">from</span> <span class="nn">nengo_dl.simulator</span> <span class="kn">import</span> <span class="n">Simulator</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Converter"><a class="viewcode-back" href="../../reference.html#nengo_dl.Converter">[docs]</a><span class="k">class</span> <span class="nc">Converter</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a Keras model to a Nengo network composed of native Nengo objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : ``tf.keras.Model``</span>
<span class="sd">        Keras model to be converted</span>
<span class="sd">    allow_fallback : bool</span>
<span class="sd">        If True, allow layers that cannot be converted to native Nengo</span>
<span class="sd">        objects to be added as a `.TensorNode` instead. Note that if this occurs, the</span>
<span class="sd">        converted Nengo network will only be runnable in the NengoDL simulator.</span>
<span class="sd">    inference_only : bool</span>
<span class="sd">        Allow layers to be converted in such a way that inference behaviour will</span>
<span class="sd">        match the source model but training behaviour will not.</span>
<span class="sd">        If ``inference_only=False`` then some</span>
<span class="sd">        layers cannot be converted to native Nengo objects (but you can</span>
<span class="sd">        still use ``allow_fallback=True`` to use a `.TensorNode` instead).</span>
<span class="sd">    max_to_avg_pool : bool</span>
<span class="sd">        If True, convert max pooling layers to average pooling layers. Note that this</span>
<span class="sd">        will change the behaviour of the network, so parameters will probably need to</span>
<span class="sd">        be re-trained in NengoDL. If ``max_to_avg_pool=False`` then max pooling layers</span>
<span class="sd">        cannot be converted to native Nengo objects (but you can</span>
<span class="sd">        still use ``allow_fallback=True`` to use a `.TensorNode` instead).</span>
<span class="sd">    split_shared_weights : bool</span>
<span class="sd">        In Keras, applying the same ``Layer`` object to different input layers will</span>
<span class="sd">        result in multiple instances of the given layer that share the same weights.</span>
<span class="sd">        This is not supported in Nengo. If ``split_shared_weights=True`` then those</span>
<span class="sd">        shared weights will be split into independent sets of weights. They will all</span>
<span class="sd">        be initialized to the same value, so the initial behaviour of the model will</span>
<span class="sd">        be unchanged, but if any further training is performed on the network then</span>
<span class="sd">        the weights in each of those instances may diverge.</span>
<span class="sd">    swap_activations : dict</span>
<span class="sd">        A dictionary mapping from TensorFlow activation functions or Nengo neuron types</span>
<span class="sd">        to TensorFlow activation functions or Nengo neuron types. This can be used to</span>
<span class="sd">        change all the activation types in a model to some other type. This is in</span>
<span class="sd">        addition to the default activation map (see `.LayerConverter`). It can be keyed</span>
<span class="sd">        based on either TensorFlow or Nengo activation types, and will be applied both</span>
<span class="sd">        before and after the default activation map, in order to support whatever swap</span>
<span class="sd">        type is most useful for a given model. In particular, ``swap_activations``</span>
<span class="sd">        can be useful for swapping rate neuron types to spiking neuron types,</span>
<span class="sd">        through e.g. ``{tf.nn.relu: nengo.SpikingRectifiedLinear()}`` or</span>
<span class="sd">        ``{nengo.RectifiedLinear(): nengo.SpikingRectifiedLinear()}``.  Or it can be</span>
<span class="sd">        used to swap activation types that don&#39;t have a native Nengo implementation,</span>
<span class="sd">        e.g. ``{tf.keras.activatons.elu: tf.keras.activations.relu}``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model : ``tf.keras.Model``</span>
<span class="sd">        The input Keras model (if input was a Sequential model then this will be the</span>
<span class="sd">        equivalent Functional model).</span>
<span class="sd">    net : `nengo.Network`</span>
<span class="sd">        The converted Nengo network.</span>
<span class="sd">    inputs : `.Converter.TensorDict`</span>
<span class="sd">        Maps from Keras model inputs to input Nodes in the converted Nengo network.</span>
<span class="sd">        For example, ``my_node = Converter(my_model).inputs[my_model.input]``.</span>
<span class="sd">    outputs : `.Converter.TensorDict`</span>
<span class="sd">        Maps from Keras model outputs to output Probes in the converted Nengo network.</span>
<span class="sd">        For example, ``my_probe = Converter(my_model).outputs[my_model.output]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">converters</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">allow_fallback</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inference_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_to_avg_pool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">split_shared_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">swap_activations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_fallback</span> <span class="o">=</span> <span class="n">allow_fallback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inference_only</span> <span class="o">=</span> <span class="n">inference_only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_to_avg_pool</span> <span class="o">=</span> <span class="n">max_to_avg_pool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_shared_weights</span> <span class="o">=</span> <span class="n">split_shared_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swap_activations</span> <span class="o">=</span> <span class="n">swap_activations</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layer_map</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_converters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">as</span> <span class="bp">self</span><span class="o">.</span><span class="n">net</span><span class="p">:</span>
            <span class="c1"># add the &quot;trainable&quot; attribute to all objects</span>
            <span class="n">configure_settings</span><span class="p">(</span><span class="n">trainable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inference_only</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_only</span><span class="p">)</span>

            <span class="c1"># convert model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_converter</span><span class="p">(</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Sequential</span><span class="p">):</span>
                <span class="c1"># if someone passes a sequential model we convert it to a functional</span>
                <span class="c1"># model and then convert that to a nengo model, so make the functional</span>
                <span class="c1"># model accessible here</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Converting sequential model to functional model&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_converter</span><span class="p">(</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">layer</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

            <span class="c1"># track inputs/outputs of model on network object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">Converter</span><span class="o">.</span><span class="n">TensorDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">input_layer</span><span class="p">,</span>
                    <span class="n">input_node_id</span><span class="p">,</span>
                    <span class="n">input_tensor_id</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">LayerConverter</span><span class="o">.</span><span class="n">get_history</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="nb">input</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer_map</span><span class="p">[</span><span class="n">input_layer</span><span class="p">][</span><span class="n">input_node_id</span><span class="p">][</span>
                    <span class="n">input_tensor_id</span>
                <span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">Converter</span><span class="o">.</span><span class="n">TensorDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">output_layer</span><span class="p">,</span>
                    <span class="n">output_node_id</span><span class="p">,</span>
                    <span class="n">output_tensor_id</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">LayerConverter</span><span class="o">.</span><span class="n">get_history</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
                <span class="n">output_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer_map</span><span class="p">[</span><span class="n">output_layer</span><span class="p">][</span><span class="n">output_node_id</span><span class="p">][</span>
                    <span class="n">output_tensor_id</span>
                <span class="p">]</span>

                <span class="c1"># add probes to outputs</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Probing </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">output_obj</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Probe</span><span class="p">(</span><span class="n">output_obj</span><span class="p">)</span>

<div class="viewcode-block" id="Converter.verify"><a class="viewcode-back" href="../../reference.html#nengo_dl.Converter.verify">[docs]</a>    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that output of converted Nengo network matches the original Keras model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        training : bool</span>
<span class="sd">            If True, check that optimizing the converted Nengo network produces the same</span>
<span class="sd">            results as optimizing the original Keras model.</span>
<span class="sd">        inputs : list of `numpy.ndarray`</span>
<span class="sd">            Testing values for model inputs (if not specified, array of ones will be</span>
<span class="sd">            used).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        success : bool</span>
<span class="sd">            True if output of Nengo network matches output of Keras model.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If output of Nengo network does not match output of Keras model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">epochs</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">inp_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,)</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">inp_vals</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="c1"># get keras model output</span>
        <span class="k">if</span> <span class="n">training</span><span class="p">:</span>
            <span class="n">out_vals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,)</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">outputs</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="mf">0.1</span><span class="p">),</span> <span class="n">loss</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">mse</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">inp_vals</span><span class="p">,</span> <span class="n">out_vals</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">)</span>

        <span class="n">keras_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">inp_vals</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keras_out</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">keras_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">keras_out</span><span class="p">]</span>

        <span class="c1"># get nengo sim output</span>
        <span class="n">inp_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inp_vals</span><span class="p">]</span>

        <span class="k">with</span> <span class="n">Simulator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net</span><span class="p">,</span> <span class="n">minibatch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span> <span class="k">as</span> <span class="n">sim</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">training</span><span class="p">:</span>
                <span class="n">keras_params</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">trainable_weights</span>
                <span class="p">)</span>
                <span class="n">nengo_params</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">sim</span><span class="o">.</span><span class="n">keras_model</span><span class="o">.</span><span class="n">trainable_weights</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">keras_params</span> <span class="o">!=</span> <span class="n">nengo_params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Number of trainable parameters in Nengo network (</span><span class="si">%d</span><span class="s2">) does not &quot;</span>
                        <span class="s2">&quot;match number of trainable parameters in Keras model (</span><span class="si">%d</span><span class="s2">)&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">nengo_params</span><span class="p">,</span> <span class="n">keras_params</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">out_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out_vals</span><span class="p">]</span>
                <span class="n">sim</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="mf">0.1</span><span class="p">),</span> <span class="n">loss</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">mse</span><span class="p">)</span>
                <span class="n">sim</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">inp_vals</span><span class="p">,</span> <span class="n">out_vals</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">)</span>

            <span class="n">sim_out</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">inp_vals</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
            <span class="n">keras_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">keras_out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">nengo_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">sim_out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">out</span><span class="p">]])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">keras_vals</span><span class="p">,</span> <span class="n">nengo_vals</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Verification failure&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Keras:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">keras_vals</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Nengo:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">nengo_vals</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Output of Keras model does not match output of converted &quot;</span>
                    <span class="s2">&quot;Nengo network&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Converter.get_converter"><a class="viewcode-back" href="../../reference.html#nengo_dl.Converter.get_converter">[docs]</a>    <span class="k">def</span> <span class="nf">get_converter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get instantiated `.LayerConverter` for the given ``Layer`` instance.</span>

<span class="sd">        Note that this caches the results, so calling the function multiple times</span>
<span class="sd">        with the same Layer instance will return the same LayerConverter instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        layer : ``tf.keras.layers.Layer``</span>
<span class="sd">            The Keras Layer being converted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converter : `.LayerConverter`</span>
<span class="sd">            LayerConverter class for converting ``layer`` to Nengo objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer_converters</span><span class="p">:</span>
            <span class="c1"># already have an instantiated converter for this layer</span>
            <span class="n">converter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer_converters</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">converter</span><span class="o">.</span><span class="n">has_weights</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_shared_weights</span><span class="p">:</span>
                <span class="c1"># TODO: allow fallback</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Multiple applications of layer </span><span class="si">%s</span><span class="s2"> detected; this is not supported &quot;</span>
                    <span class="s2">&quot;unless split_shared_weights=True&quot;</span> <span class="o">%</span> <span class="n">layer</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">converter</span>

        <span class="c1"># check if there is a registered builder for this layer type</span>
        <span class="n">ConverterClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">converters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">layer</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># perform custom checks in layer converters</span>
        <span class="k">if</span> <span class="n">ConverterClass</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="s2">&quot;Layer type </span><span class="si">%s</span><span class="s2"> does not have a registered converter&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span>
                <span class="n">layer</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">convertible</span><span class="p">,</span> <span class="n">error_msg</span> <span class="o">=</span> <span class="n">ConverterClass</span><span class="o">.</span><span class="n">convertible</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">convertible</span><span class="p">:</span>
                <span class="n">ConverterClass</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">ConverterClass</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># this means that there is no LayerConverter compatible with this layer</span>
            <span class="c1"># (either because it has an unknown type, or it failed the ``.convertible``</span>
            <span class="c1"># check due to its internal parameterization)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_fallback</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">Falling back to TensorNode.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">error_msg</span> <span class="o">+</span> <span class="s2">&quot;. &quot;</span> <span class="k">if</span> <span class="n">error_msg</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">ConverterClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">converters</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">Unable to convert layer </span><span class="si">%s</span><span class="s2"> to native Nengo objects; set &quot;</span>
                    <span class="s2">&quot;allow_fallback=True if you would like to use a TensorNode &quot;</span>
                    <span class="s2">&quot;instead, or consider registering a custom LayerConverter for this &quot;</span>
                    <span class="s2">&quot;layer type.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">error_msg</span> <span class="o">+</span> <span class="s2">&quot;. &quot;</span> <span class="k">if</span> <span class="n">error_msg</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">layer</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="n">converter</span> <span class="o">=</span> <span class="n">ConverterClass</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_converters</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">converter</span>

        <span class="k">return</span> <span class="n">converter</span></div>

<div class="viewcode-block" id="Converter.register"><a class="viewcode-back" href="../../reference.html#nengo_dl.Converter.register">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">keras_layer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A decorator for adding a class to the converter registry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keras_layer : ``tf.keras.layers.Layer``</span>
<span class="sd">            The Layer associated with the conversion function being registered.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">register_converter</span><span class="p">(</span><span class="n">convert_cls</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">keras_layer</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">converters</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Layer &#39;</span><span class="si">%s</span><span class="s2">&#39; already has a converter. Overwriting.&quot;</span> <span class="o">%</span> <span class="n">keras_layer</span>
                <span class="p">)</span>

            <span class="bp">cls</span><span class="o">.</span><span class="n">converters</span><span class="p">[</span><span class="n">keras_layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_cls</span>

            <span class="k">return</span> <span class="n">convert_cls</span>

        <span class="k">return</span> <span class="n">register_converter</span></div>

<div class="viewcode-block" id="Converter.TensorDict"><a class="viewcode-back" href="../../reference.html#nengo_dl.Converter.TensorDict">[docs]</a>    <span class="k">class</span> <span class="nc">TensorDict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;A dictionary-like object that works with TensorFlow Tensors.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">experimental_ref</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">experimental_ref</span><span class="p">()</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="LayerConverter"><a class="viewcode-back" href="../../reference.html#nengo_dl.LayerConverter">[docs]</a><span class="k">class</span> <span class="nc">LayerConverter</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for converter classes, which contain the logic for mapping some Keras</span>
<span class="sd">    layer type to Nengo objects.</span>

<span class="sd">    Subclasses must implement the `.LayerConverter.convert` method. They may optionally</span>
<span class="sd">    extend `.LayerConverter.convertible` if this layer type requires custom logic for</span>
<span class="sd">    whether or not a layer can be converted to Nengo objects.</span>

<span class="sd">    Subclasses should override the ``unsupported_args`` class parameter if there are</span>
<span class="sd">    certain non-default Layer attributes that are not supported by the converter.</span>
<span class="sd">    This is a list of names for attributes that must have the default value for the</span>
<span class="sd">    layer to be convertible. The default is assumed to be ``None``, or a tuple of</span>
<span class="sd">    ``(&quot;attribute_name&quot;, default_value)`` can be specified. If there are parameters</span>
<span class="sd">    that are supported in inference mode but not in training mode, they should be</span>
<span class="sd">    added to the ``unsupported_training_args`` parameter.</span>

<span class="sd">    Subclasses should override the ``has_weights`` class parameter if the layer type</span>
<span class="sd">    being converted contains internal weights (this affects how the converter will</span>
<span class="sd">    handle duplicate layers).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    layer : ``tf.keras.layers.Layer``</span>
<span class="sd">        The Layer object being converted.</span>
<span class="sd">    converter : `.Converter`</span>
<span class="sd">        The parent Converter class running the conversion process.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># maps from TensorFlow activation functions to Nengo neuron types</span>
    <span class="n">activation_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="kc">None</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">activations</span><span class="o">.</span><span class="n">linear</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">activations</span><span class="o">.</span><span class="n">relu</span><span class="p">:</span> <span class="n">nengo</span><span class="o">.</span><span class="n">RectifiedLinear</span><span class="p">(),</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">:</span> <span class="n">nengo</span><span class="o">.</span><span class="n">RectifiedLinear</span><span class="p">(),</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">activations</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">:</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">(</span><span class="n">tau_ref</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">:</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">(</span><span class="n">tau_ref</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c1"># attributes of the Keras layer that are not supported for non-default values.</span>
    <span class="c1"># the default value is assumed to be None, or a tuple of</span>
    <span class="c1"># (&quot;attr_name&quot;, default_value) can be specified</span>
    <span class="n">unsupported_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># attributes that are supported in inference_only mode but otherwise not</span>
    <span class="n">unsupported_training_args</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># whether or not this layer contains trainable weights (this indicates whether</span>
    <span class="c1"># this layer is affected by split_shared_weights)</span>
    <span class="n">has_weights</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">converter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layer</span> <span class="o">=</span> <span class="n">layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span> <span class="o">=</span> <span class="n">converter</span>

<div class="viewcode-block" id="LayerConverter.add_nengo_obj"><a class="viewcode-back" href="../../reference.html#nengo_dl.LayerConverter.add_nengo_obj">[docs]</a>    <span class="k">def</span> <span class="nf">add_nengo_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">biases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a Nengo object for the given Node of this layer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">            The index of the Keras Node currently being built on this layer.</span>
<span class="sd">        biases : `numpy.ndarray` or None</span>
<span class="sd">            If not None, add trainable biases with the given value.</span>
<span class="sd">        activation : callable or None</span>
<span class="sd">            The TensorFlow activation function to be used (``None`` will be</span>
<span class="sd">            interpreted as linear activation).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : `nengo.Node` or `nengo.ensemble.Neurons` or `nengo_dl.TensorNode`</span>
<span class="sd">            The Nengo object whose output corresponds to the output of the given Keras</span>
<span class="sd">            Node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">node_id</span>

        <span class="c1"># apply manually specified swaps</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">swap_activations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">activation</span><span class="p">,</span> <span class="n">activation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">activation</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_map</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">activation</span><span class="p">,</span> <span class="n">nengo</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">NeuronType</span>
        <span class="p">):</span>
            <span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">activation</span><span class="p">,</span> <span class="n">activation</span><span class="p">)</span>

            <span class="c1"># apply any nengo-&gt;nengo swaps</span>
            <span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">swap_activations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">activation</span><span class="p">,</span> <span class="n">activation</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">activation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># linear activation, uses a passthrough Node</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span>
                    <span class="n">size_in</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)),</span> <span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">biases</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># use a connection from a constant node (so that the bias</span>
                    <span class="c1"># values will be trainable)</span>
                    <span class="n">bias_node</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.bias_node&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span>
                        <span class="n">bias_node</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">biases</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">synapse</span><span class="o">=</span><span class="kc">None</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use ensemble to implement the appropriate neuron type</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)),</span>
                    <span class="mi">1</span><span class="p">,</span>
                    <span class="n">neuron_type</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                    <span class="n">gain</span><span class="o">=</span><span class="n">nengo</span><span class="o">.</span><span class="n">dists</span><span class="o">.</span><span class="n">Choice</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">bias</span><span class="o">=</span><span class="n">nengo</span><span class="o">.</span><span class="n">dists</span><span class="o">.</span><span class="n">Choice</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">biases</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">biases</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">neurons</span>
                <span class="k">if</span> <span class="n">biases</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># ensembles always have biases, so if biases=None we just use</span>
                    <span class="c1"># all-zero biases and mark them as non-trainable</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">net</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span><span class="o">.</span><span class="n">trainable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">allow_fallback</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Activation type </span><span class="si">%s</span><span class="s2"> does not have a native Nengo equivalent; &quot;</span>
                <span class="s2">&quot;falling back to a TensorNode&quot;</span> <span class="o">%</span> <span class="n">activation</span>
            <span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">TensorNode</span><span class="p">(</span>
                <span class="n">activation</span><span class="p">,</span>
                <span class="n">shape_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">),</span>
                <span class="n">pass_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported activation type (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Created </span><span class="si">%s</span><span class="s2"> (size=</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">size_out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="LayerConverter.add_connection"><a class="viewcode-back" href="../../reference.html#nengo_dl.LayerConverter.add_connection">[docs]</a>    <span class="k">def</span> <span class="nf">add_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">input_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trainable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a Connection from one of the inputs of the Node being built to the</span>
<span class="sd">        Nengo object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">            The index of the Keras Node currently being built on this layer.</span>
<span class="sd">        obj : ``NengoObject``</span>
<span class="sd">            The Nengo object implementing this Node.</span>
<span class="sd">        input_idx : int</span>
<span class="sd">            Which of the inputs we want to add a Connection for (in the case of</span>
<span class="sd">            layers that have multiple inputs).</span>
<span class="sd">        trainable : bool</span>
<span class="sd">            Whether or not the weights associated with the created Connection</span>
<span class="sd">            should be trainable.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Will be passed on to `nengo.Connection`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conn : `nengo.Connection`</span>
<span class="sd">            The constructed Connection object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_input_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">tensor_idx</span><span class="o">=</span><span class="n">input_idx</span><span class="p">),</span>
            <span class="n">obj</span><span class="p">,</span>
            <span class="n">synapse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">net</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="n">conn</span><span class="p">]</span><span class="o">.</span><span class="n">trainable</span> <span class="o">=</span> <span class="n">trainable</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Connected </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2"> (trainable=</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">pre</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">post</span><span class="p">,</span> <span class="n">trainable</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">conn</span></div>

<div class="viewcode-block" id="LayerConverter.get_input_obj"><a class="viewcode-back" href="../../reference.html#nengo_dl.LayerConverter.get_input_obj">[docs]</a>    <span class="k">def</span> <span class="nf">get_input_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">tensor_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Nengo object corresponding to the given input of this layer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">            The index of the Keras Node currently being built on this layer.</span>
<span class="sd">        tensor_idx : int</span>
<span class="sd">            The index of the input we want to look up (for layers with multiple inputs).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : `nengo.Node` or `nengo.ensemble.Neurons` or `nengo_dl.TensorNode`</span>
<span class="sd">            The Nengo object whose output corresponds to the given input of this layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">inbound_nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span>

        <span class="n">input_tensors</span> <span class="o">=</span> <span class="n">input_node</span><span class="o">.</span><span class="n">input_tensors</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_tensors</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">input_tensors</span><span class="p">[</span><span class="n">tensor_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">tensor_idx</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">input_tensors</span>

        <span class="n">input_layer</span><span class="p">,</span> <span class="n">input_node_id</span><span class="p">,</span> <span class="n">input_tensor_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_history</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">input_node_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">layer_map</span><span class="p">[</span><span class="n">input_layer</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">layer_map</span><span class="p">[</span><span class="n">input_layer</span><span class="p">][</span><span class="n">input_node_id</span><span class="p">][</span><span class="n">input_tensor_id</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_output</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">include_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks up the input or output shape of this Node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_output : &quot;input&quot; or &quot;output&quot;</span>
<span class="sd">            Whether we want the input or output shape.</span>
<span class="sd">        node_id : int</span>
<span class="sd">            The node whose shape we want to look up.</span>
<span class="sd">        include_batch : bool</span>
<span class="sd">            Whether or not the returned shape should include the batch dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shape : (list of) tuple of int</span>
<span class="sd">            A single tuple shape if the node has one input/output, or a list of shapes</span>
<span class="sd">            if the node as multiple inputs/outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># note: layer.get_input/output_shape_at is generally equivalent to</span>
        <span class="c1"># layer.input/output_shape, except when the layer is called multiple times</span>
        <span class="c1"># with different shapes, in which case input/output_shape is not well defined</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;get_</span><span class="si">%s</span><span class="s2">_shape_at&quot;</span> <span class="o">%</span> <span class="n">input_output</span><span class="p">)</span>

        <span class="c1"># get the shape</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_batch</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># multiple inputs/outputs; trim the batch from each one</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">shape</span>

<div class="viewcode-block" id="LayerConverter.input_shape"><a class="viewcode-back" href="../../reference.html#nengo_dl.LayerConverter.input_shape">[docs]</a>    <span class="k">def</span> <span class="nf">input_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">include_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the input shape of the given node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">            The node whose shape we want to look up.</span>
<span class="sd">        include_batch : bool</span>
<span class="sd">            Whether or not the returned shape should include the batch dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shape : (list of) tuple of int</span>
<span class="sd">            A single tuple shape if the node has one input, or a list of shapes</span>
<span class="sd">            if the node as multiple inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_shape</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">include_batch</span><span class="o">=</span><span class="n">include_batch</span><span class="p">)</span></div>

<div class="viewcode-block" id="LayerConverter.output_shape"><a class="viewcode-back" href="../../reference.html#nengo_dl.LayerConverter.output_shape">[docs]</a>    <span class="k">def</span> <span class="nf">output_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">include_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the output shape of the given node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">            The node whose shape we want to look up.</span>
<span class="sd">        include_batch : bool</span>
<span class="sd">            Whether or not the returned shape should include the batch dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shape : (list of) tuple of int</span>
<span class="sd">            A single tuple shape if the node has one output, or a list of shapes</span>
<span class="sd">            if the node as multiple outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_shape</span><span class="p">(</span><span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">include_batch</span><span class="o">=</span><span class="n">include_batch</span><span class="p">)</span></div>

<div class="viewcode-block" id="LayerConverter.get_history"><a class="viewcode-back" href="../../reference.html#nengo_dl.LayerConverter.get_history">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_history</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Keras history (layer/node_idx/tensor_idx) that defined this tensor.</span>

<span class="sd">        This function contains additional logic so that if ``tensor`` is the output of</span>
<span class="sd">        a Model then the history will trace into the internal layers of that Model</span>
<span class="sd">        (rather than skipping to the input of that Model, which is the default Keras</span>
<span class="sd">        history).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor : ``tf.Tensor``</span>
<span class="sd">            The tensor whose Keras history we want to look up.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        layer : ``tf.keras.layers.Layer``</span>
<span class="sd">            The Layer object that created this Tensor.</span>
<span class="sd">        node_index : int</span>
<span class="sd">            The index of the outbound node of ``layer`` that created this Tensor.</span>
<span class="sd">        tensor_index : int</span>
<span class="sd">            The index in the output of the Node corresponding to this Tensor (for</span>
<span class="sd">            Nodes with multiple outputs).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">layer</span><span class="p">,</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">tensor_index</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">_keras_history</span>

        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
            <span class="c1"># models have an output Identity transform that stores the history that</span>
            <span class="c1"># &quot;skips&quot; the internals of the model; we want to traverse into the internals</span>
            <span class="c1"># of the model, so we go back to the input of that identity op (which</span>
            <span class="c1"># is the real output tensor from the model)</span>
            <span class="k">assert</span> <span class="n">tensor</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;Identity&quot;</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">layer</span><span class="p">,</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">tensor_index</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">_keras_history</span>

        <span class="k">return</span> <span class="n">layer</span><span class="p">,</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">tensor_index</span></div>

<div class="viewcode-block" id="LayerConverter.convertible"><a class="viewcode-back" href="../../reference.html#nengo_dl.LayerConverter.convertible">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">convertible</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">converter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the given Keras layer is convertible to native Nengo objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        layer : ``tf.keras.layers.Layer``</span>
<span class="sd">            The Keras Layer we want to convert.</span>
<span class="sd">        converter : `.Converter`</span>
<span class="sd">            The Converter object running the conversion process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        convertible : bool</span>
<span class="sd">            True if the layer can be converted to native Nengo objects, else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if the layer uses any unsupported arguments</span>
        <span class="n">unsupported</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">unsupported_args</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">converter</span><span class="o">.</span><span class="n">inference_only</span><span class="p">:</span>
            <span class="n">unsupported</span> <span class="o">=</span> <span class="n">unsupported</span> <span class="o">+</span> <span class="bp">cls</span><span class="o">.</span><span class="n">unsupported_training_args</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">unsupported</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">default</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arg</span><span class="p">,</span> <span class="n">default</span> <span class="o">=</span> <span class="n">arg</span>

            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="n">default</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2"> has value </span><span class="si">%s</span><span class="s2"> != </span><span class="si">%s</span><span class="s2">, which is not supported&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">layer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">arg</span><span class="p">,</span>
                    <span class="n">val</span><span class="p">,</span>
                    <span class="n">default</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">unsupported_training_args</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; (unless inference_only=True)&quot;</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>

        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LayerConverter.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.LayerConverter.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the given node of this layer to Nengo objects</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">            The index of the inbound node to be converted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : ``NengoObject``</span>
<span class="sd">            Nengo object whose output corresponds to the output of the Keras layer node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement convert&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertModel"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertModel">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertModel</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.Model`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertModel.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertModel.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="c1"># should never be building a model except in the top-level converter</span>
        <span class="k">assert</span> <span class="n">node_id</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">30</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Converting model </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># functional models should already have been built when the model</span>
        <span class="c1"># was instantiated</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">built</span>

        <span class="c1"># trace the model to find all the tensors (which correspond to layers/nodes)</span>
        <span class="c1"># that need to be built into the Nengo network</span>
        <span class="n">source_tensors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_tensors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c1"># sort tensors so that order of model inputs/outputs is preserved</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">:</span>
                    <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">source_tensors</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">source_tensors</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_key</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">source_tensors</span><span class="p">:</span>
            <span class="c1"># look up the layer/node to be converted</span>
            <span class="n">model_layer</span><span class="p">,</span> <span class="n">model_node_id</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_history</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">model_node_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">layer_map</span><span class="p">[</span><span class="n">model_layer</span><span class="p">]:</span>
                <span class="c1"># already built this node</span>
                <span class="k">continue</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">30</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Converting layer </span><span class="si">%s</span><span class="s2"> node </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">model_layer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">model_node_id</span><span class="p">)</span>

            <span class="c1"># get the layerconverter object</span>
            <span class="n">layer_converter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">get_converter</span><span class="p">(</span><span class="n">model_layer</span><span class="p">)</span>

            <span class="c1"># build the Nengo objects</span>
            <span class="n">nengo_layer</span> <span class="o">=</span> <span class="n">layer_converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">model_node_id</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">nengo_layer</span><span class="p">,</span> <span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">nengo</span><span class="o">.</span><span class="n">ensemble</span><span class="o">.</span><span class="n">Neurons</span><span class="p">,</span> <span class="n">TensorNode</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="c1"># add output of layer_converter to layer_map</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">layer_map</span><span class="p">[</span><span class="n">model_layer</span><span class="p">][</span><span class="n">model_node_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nengo_layer</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">30</span><span class="p">)</span></div>

        <span class="c1"># note: not returning anything, because we don&#39;t need to store anything in</span>
        <span class="c1"># the layer map (this network is only used by the top-level converter class)</span>

<div class="viewcode-block" id="ConvertModel.trace_tensors"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertModel.trace_tensors">[docs]</a>    <span class="k">def</span> <span class="nf">trace_tensors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensors</span><span class="p">,</span> <span class="n">results</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively trace all the upstream layer tensors, starting from ``tensors``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensors : list of ``tf.Tensor``</span>
<span class="sd">            Tensors representing the output of some layers.</span>
<span class="sd">        results : list of ``tf.Tensor``</span>
<span class="sd">            Output tensors for all the layers leading up to and including ``tensors``.</span>
<span class="sd">            This will be populated in-place during the recursive execution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : list of ``tf.Tensor``</span>
<span class="sd">            The same as the ``results`` parameter (returned so that the top-level call,</span>
<span class="sd">            which may not have a reference to the ``results`` list can get the results).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># brief intro to the keras functional graph structure:</span>
        <span class="c1"># - a node represents the application of some layer to an input tensor</span>
        <span class="c1"># - whenever a layer B is applied to the output of layer A a new Node is</span>
        <span class="c1">#   created; this Node is added to A.outbound_nodes and B.inbound_nodes</span>
        <span class="c1"># - every Node has input tensors x (which will be the input to B) and output</span>
        <span class="c1">#   tensors y (the output of B)</span>
        <span class="c1"># - every tensor tracks the layer/node that created it in _keras_history</span>
        <span class="c1">#   (so the _keras_history of y would be (B, 0) (where 0 is the index within</span>
        <span class="c1">#   B.inbound_nodes corresponding to the node that created y); note that x was</span>
        <span class="c1">#   created whenever A was applied to some other layer, so its _keras_history is</span>
        <span class="c1">#   unrelated to the application of B</span>

        <span class="c1"># for example, if we apply multiple layers B/C/D to the output of some</span>
        <span class="c1"># layer A:</span>
        <span class="c1">#  b = B(a)</span>
        <span class="c1">#  c = C(a)</span>
        <span class="c1">#  d = D(a)</span>
        <span class="c1"># each time will create a new Node. so we will have 3 nodes total;</span>
        <span class="c1"># A will have 3 outbound nodes, and B/C/D will each have one inbound node.</span>
        <span class="c1"># every node will have the same input tensor (a), but a different</span>
        <span class="c1"># output tensor (the output of B/C/D) with keras_history (B, 0), (C, 0), and</span>
        <span class="c1"># (D, 0).</span>

        <span class="c1"># on the other hand, if we take one layer and apply it to multiple inputs:</span>
        <span class="c1">#  d0 = D(a)</span>
        <span class="c1">#  d1 = D(b)</span>
        <span class="c1">#  d2 = D(c)</span>
        <span class="c1"># again we will have 3 nodes total. D will 3 inbound nodes, and A/B/C will each</span>
        <span class="c1"># have one outbound node. each node will have a different input tensor (the</span>
        <span class="c1"># output of A/B/C), but _also a different output tensor_ (the result of applying</span>
        <span class="c1"># D to each one of those inputs) with keras history (D, 0), (D, 1), (D, 2)</span>

        <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;===starting trace_tensors===&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Tracing tensors </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tensors</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">tensors</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">tensor</span> <span class="ow">is</span> <span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">results</span><span class="p">):</span>
                <span class="c1"># already traced this tensor</span>
                <span class="k">continue</span>

            <span class="n">layer</span><span class="p">,</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_history</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;---&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Layer </span><span class="si">%s</span><span class="s2"> node </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">layer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node_index</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">inbound_nodes</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">inbound_nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">inbound_layers</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Input layers </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">inbound_layers</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Input tensors </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">input_tensors</span><span class="p">)</span>

                    <span class="c1"># not an input layer, so continue recursion</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trace_tensors</span><span class="p">(</span>
                        <span class="n">nest</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input_tensors</span><span class="p">),</span> <span class="n">results</span><span class="o">=</span><span class="n">results</span>
                    <span class="p">)</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;===done trace_tensors===&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div></div>


<div class="viewcode-block" id="ConvertSequential"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertSequential">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Sequential</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertSequential</span><span class="p">(</span><span class="n">ConvertModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.Sequential`` to Nengo objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_model</span><span class="p">,</span> <span class="n">converter</span><span class="p">):</span>
        <span class="c1"># convert sequential model to functional model</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">seq_model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_shape</span>

        <span class="n">inp</span> <span class="o">=</span> <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">batch_shape</span><span class="o">=</span><span class="n">input_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">seq_model</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">func_model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">func_model</span><span class="p">,</span> <span class="n">converter</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConvertFallback"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertFallback">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertFallback</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert layers which do not have a native Nengo equivalent into a</span>
<span class="sd">    `.TensorNode`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># copy layer, so that any changes to the layer (e.g., rebuilding it), do not</span>
        <span class="c1"># affect the source model</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">get_config</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">built</span><span class="p">:</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_shape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">include_batch</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tensor_layer</span> <span class="o">=</span> <span class="n">Layer</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>

<div class="viewcode-block" id="ConvertFallback.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertFallback.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using TensorNode </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_layer</span><span class="p">)</span>

        <span class="n">input_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_input_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_layer</span><span class="p">(</span>
            <span class="n">input_obj</span><span class="p">,</span> <span class="n">shape_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying to </span><span class="si">%s</span><span class="s2">, created </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">input_obj</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="ConvertAvgPool"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAvgPool">[docs]</a><span class="k">class</span> <span class="nc">ConvertAvgPool</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for converting average pooling layers to Nengo objects.&quot;&quot;&quot;</span>

    <span class="c1"># &quot;same&quot; padding not supported because TensorFlow average pooling does not count</span>
    <span class="c1"># the padded cells in the average, which we don&#39;t have a way to do using Convolution</span>
    <span class="n">unsupported_args</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;padding&quot;</span><span class="p">,</span> <span class="s2">&quot;valid&quot;</span><span class="p">)]</span>

<div class="viewcode-block" id="ConvertAvgPool.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAvgPool.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nengo_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">to_tuple</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">val</span><span class="p">,)</span> <span class="o">*</span> <span class="n">dimensions</span>

            <span class="k">return</span> <span class="n">val</span>

        <span class="n">spatial_shape</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">data_format</span> <span class="o">==</span> <span class="s2">&quot;channels_last&quot;</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="p">)</span>

        <span class="c1"># the default values here are for GlobalAveragePooling (which doesn&#39;t have</span>
        <span class="c1"># these attributes)</span>
        <span class="n">pool_size</span> <span class="o">=</span> <span class="n">to_tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;pool_size&quot;</span><span class="p">,</span> <span class="n">spatial_shape</span><span class="p">))</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;padding&quot;</span><span class="p">,</span> <span class="s2">&quot;valid&quot;</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="n">to_tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;strides&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># the idea here is that we set up a convolutional transform with weights 1/n,</span>
        <span class="c1"># which will have the effect of implementing average pooling</span>
        <span class="n">n_filters</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">data_format</span> <span class="o">==</span> <span class="s2">&quot;channels_last&quot;</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">n_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">pool_size</span><span class="p">)</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_filters</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_pool</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_pool</span><span class="p">,</span> <span class="n">pool_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_filters</span><span class="p">,</span> <span class="n">n_filters</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">pool_conv</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Convolution</span><span class="p">(</span>
            <span class="n">n_filters</span><span class="o">=</span><span class="n">n_filters</span><span class="p">,</span>
            <span class="n">input_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">),</span>
            <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
            <span class="n">kernel_size</span><span class="o">=</span><span class="n">pool_size</span><span class="p">,</span>
            <span class="n">init</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
            <span class="n">channels_last</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">data_format</span> <span class="o">==</span> <span class="s2">&quot;channels_last&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">pool_conv</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="ConvertAvgPool.convertible"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAvgPool.convertible">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">convertible</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">converter</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">layer</span><span class="p">,</span>
                <span class="p">(</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">MaxPool1D</span><span class="p">,</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">MaxPool2D</span><span class="p">,</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">MaxPool3D</span><span class="p">,</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalMaxPool1D</span><span class="p">,</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalMaxPool2D</span><span class="p">,</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalMaxPool3D</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">converter</span><span class="o">.</span><span class="n">max_to_avg_pool</span>
        <span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Cannot convert max pooling layers to native Nengo objects; consider &quot;</span>
                <span class="s2">&quot;setting max_to_avg_pool=True to use average pooling instead&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>

        <span class="n">unsupported</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">unsupported_args</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;padding&quot;</span><span class="p">):</span>
            <span class="c1"># global layers don&#39;t have this attribute, so we temporarily remove it</span>
            <span class="c1"># from the unsupported args</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">unsupported_args</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">convertible</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convertible</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">converter</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># reset the unsupported args</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">unsupported_args</span> <span class="o">=</span> <span class="n">unsupported</span>

        <span class="k">return</span> <span class="n">convertible</span></div></div>


<div class="viewcode-block" id="ConvertActivation"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertActivation">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Activation</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertActivation</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.Activation`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertActivation.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertActivation.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nengo_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="ConvertAdd"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAdd">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Add</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertAdd</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.Add`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertAdd.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAdd.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nengo_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">input</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">input_idx</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="ConvertAverage"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAverage">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Average</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertAverage</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.Average`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertAverage.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAverage.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nengo_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">input</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span>
                <span class="n">node_id</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">input_idx</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="ConvertAvgPool1D"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAvgPool1D">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">AvgPool1D</span><span class="p">)</span>
<span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">MaxPool1D</span><span class="p">)</span>
<span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalAvgPool1D</span><span class="p">)</span>
<span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalMaxPool1D</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertAvgPool1D</span><span class="p">(</span><span class="n">ConvertAvgPool</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert ``tf.keras.layers.AvgPool1D`` to Nengo objects.</span>

<span class="sd">    Also works for ``tf.keras.layers.GlobalAvgPool1D``, and</span>
<span class="sd">    ``tf.keras.layers.MaxPool1D``/``GlobalMaxPool1D`` (if ``max_to_avg_pool=True``).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertAvgPool1D.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAvgPool1D.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertAvgPool2D"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAvgPool2D">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">AvgPool2D</span><span class="p">)</span>
<span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">MaxPool2D</span><span class="p">)</span>
<span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalAvgPool2D</span><span class="p">)</span>
<span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalMaxPool2D</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertAvgPool2D</span><span class="p">(</span><span class="n">ConvertAvgPool</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert ``tf.keras.layers.AvgPool2D`` to Nengo objects.</span>

<span class="sd">    Also works for ``tf.keras.layers.GlobalAvgPool2D``, and</span>
<span class="sd">    ``tf.keras.layers.MaxPool2D``/``GlobalMaxPool2D`` (if ``max_to_avg_pool=True``).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertAvgPool2D.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAvgPool2D.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertAvgPool3D"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAvgPool3D">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">AvgPool3D</span><span class="p">)</span>
<span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">MaxPool3D</span><span class="p">)</span>
<span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalAvgPool3D</span><span class="p">)</span>
<span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalMaxPool3D</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertAvgPool3D</span><span class="p">(</span><span class="n">ConvertAvgPool</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert ``tf.keras.layers.AvgPool3D`` to Nengo objects.</span>

<span class="sd">    Also works for ``tf.keras.layers.GlobalAvgPool3D``, and</span>
<span class="sd">    ``tf.keras.layers.MaxPool3D``/``GlobalMaxPool3D`` (if ``max_to_avg_pool=True``).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertAvgPool3D.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertAvgPool3D.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertBatchNormalization"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertBatchNormalization">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BatchNormalization</span><span class="p">)</span>
<span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">BatchNormalizationV2</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertBatchNormalization</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.BatchNormalization`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertBatchNormalization.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertBatchNormalization.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="c1"># look up the batch normalization parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">scale</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">center</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">mean</span><span class="p">,</span> <span class="n">variance</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">batch_get_value</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">moving_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">moving_variance</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># compute the fixed affine transform values for this layer</span>
        <span class="n">variance</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">epsilon</span>

        <span class="n">stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">/</span> <span class="n">stddev</span>
        <span class="n">bias</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">-</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">mean</span> <span class="o">/</span> <span class="n">stddev</span>

        <span class="c1"># build output object</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nengo_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

        <span class="c1"># the batch normalization parameters will be n-dimensional, where n is the</span>
        <span class="c1"># length of the axis specified in the batch normalization layer. so we need</span>
        <span class="c1"># to set up a connection structure so that all the elements of the output</span>
        <span class="c1"># corresponding to one of those axis elements will share the same parameter</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># not counting batch dimension</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">size_in</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">))</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>

        <span class="c1"># broadcast scale/bias along the non-axis dimensions, so that we can apply the</span>
        <span class="c1"># same scale/bias to all those elements</span>
        <span class="n">broadcast_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">))</span>
        <span class="n">broadcast_bias</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idxs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]):</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">broadcast_scale</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">broadcast_bias</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">bias</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">broadcast_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">broadcast_scale</span><span class="p">)</span>
        <span class="n">broadcast_bias</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">broadcast_bias</span><span class="p">)</span>

        <span class="c1"># connect up bias node to output</span>
        <span class="n">bias_node</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">broadcast_bias</span><span class="p">)</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">bias_node</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">synapse</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">net</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="n">conn</span><span class="p">]</span><span class="o">.</span><span class="n">trainable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># connect input to output, scaled by the batch normalization scale</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_input_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">),</span>
            <span class="n">output</span><span class="p">,</span>
            <span class="n">synapse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">broadcast_scale</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">net</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="n">conn</span><span class="p">]</span><span class="o">.</span><span class="n">trainable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># this is an alternate approach, where rather than broadcasting scale/bias,</span>
        <span class="c1"># we create individual connections for each element in the batch normalization</span>
        <span class="c1"># axis. this will result in smaller weight matrices, but more Connections</span>
        <span class="c1"># TODO: figure out where the tradeoffs lie between these two approaches</span>
        <span class="c1"># bias_node = nengo.Node(np.ones(idxs[slices].size))</span>
        <span class="c1">#</span>
        <span class="c1"># # for each element in the batch normalization axis</span>
        <span class="c1"># for i in range(idxs.shape[axis]):</span>
        <span class="c1">#     # slice out one element of the output along the axis</span>
        <span class="c1">#     slices[axis] = i</span>
        <span class="c1">#     slice_idxs = np.ravel(idxs[slices])</span>
        <span class="c1">#     sliced_output = output[slice_idxs]</span>
        <span class="c1">#</span>
        <span class="c1">#     # connect up bias</span>
        <span class="c1">#     conn = nengo.Connection(</span>
        <span class="c1">#         bias_node, sliced_output, synapse=None, transform=bias[i],</span>
        <span class="c1">#     )</span>
        <span class="c1">#     self.converter.net.config[conn].trainable = False</span>
        <span class="c1">#</span>
        <span class="c1">#     # connect up input with scale applied</span>
        <span class="c1">#     conn = nengo.Connection(</span>
        <span class="c1">#         self.get_input_obj(node_id)[slice_idxs],</span>
        <span class="c1">#         sliced_output,</span>
        <span class="c1">#         synapse=None,</span>
        <span class="c1">#         transform=scale[i],</span>
        <span class="c1">#     )</span>
        <span class="c1">#     self.converter.net.config[conn].trainable = False</span>

        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="ConvertBatchNormalization.convertible"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertBatchNormalization.convertible">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">convertible</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">converter</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">converter</span><span class="o">.</span><span class="n">inference_only</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Cannot convert BatchNormalization layer to native Nengo objects &quot;</span>
                <span class="s2">&quot;unless inference_only=True&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convertible</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">converter</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertConcatenate"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConcatenate">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Concatenate</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertConcatenate</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.Concatenate`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertConcatenate.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConcatenate.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nengo_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

        <span class="c1"># axis-1 because not counting batch dimension</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">axis</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">axis</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">axis</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idxs</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)])</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">offsets</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">input</span><span class="p">)):</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span>
                <span class="n">node_id</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">idxs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)])],</span> <span class="n">input_idx</span><span class="o">=</span><span class="n">i</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="ConvertConcatenate.convertible"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConcatenate.convertible">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">convertible</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">converter</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot concatenate along batch dimension (axis 0)&quot;</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convertible</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">converter</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertConv"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConv">[docs]</a><span class="k">class</span> <span class="nc">ConvertConv</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for converting convolutional layers to Nengo objects.&quot;&quot;&quot;</span>

    <span class="n">has_weights</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ConvertConv.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConv.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="c1"># look up parameter values from source layer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">use_bias</span><span class="p">:</span>
            <span class="n">kernel</span><span class="p">,</span> <span class="n">biases</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">batch_get_value</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">kernel</span><span class="p">)</span>
            <span class="n">biases</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># create nengo object to implement activation function</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nengo_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">use_bias</span><span class="p">:</span>
            <span class="c1"># conv layer biases are per-output-channel, rather than per-output-element,</span>
            <span class="c1"># so we need to set up a nengo connection structure that will have one</span>
            <span class="c1"># bias parameter shared across all the spatial dimensions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">data_format</span> <span class="o">==</span> <span class="s2">&quot;channels_first&quot;</span><span class="p">:</span>
                <span class="n">spatial_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">bias_node</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;conv_bias&quot;</span><span class="p">)</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span>
                        <span class="n">bias_node</span><span class="p">,</span>
                        <span class="n">output</span><span class="p">[</span><span class="n">offset</span> <span class="p">:</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">spatial_size</span><span class="p">],</span>
                        <span class="n">transform</span><span class="o">=</span><span class="n">biases</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">synapse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">offset</span> <span class="o">+=</span> <span class="n">spatial_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spatial_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">bias_node</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;conv_bias&quot;</span><span class="p">)</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span>
                        <span class="n">bias_node</span><span class="p">,</span>
                        <span class="n">output</span><span class="p">[</span><span class="n">idxs</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]],</span>
                        <span class="n">transform</span><span class="o">=</span><span class="n">biases</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">synapse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="c1"># set up a convolutional transform that matches the layer parameters</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Convolution</span><span class="p">(</span>
            <span class="n">n_filters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">filters</span><span class="p">,</span>
            <span class="n">input_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">),</span>
            <span class="n">kernel_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">,</span>
            <span class="n">strides</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">strides</span><span class="p">,</span>
            <span class="n">padding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">channels_last</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">data_format</span> <span class="o">==</span> <span class="s2">&quot;channels_last&quot;</span><span class="p">,</span>
            <span class="n">init</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">trainable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="ConvertConv1D"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConv1D">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Conv1D</span><span class="p">,)</span>
<span class="k">class</span> <span class="nc">ConvertConv1D</span><span class="p">(</span><span class="n">ConvertConv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.Conv1D`` to Nengo objects.&quot;&quot;&quot;</span>

    <span class="n">unsupported_args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;dilation_rate&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
    <span class="p">]</span>
    <span class="n">unsupported_training_args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;kernel_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bias_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;activity_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;kernel_constraint&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bias_constraint&quot;</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="ConvertConv1D.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConv1D.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertConv2D"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConv2D">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">,)</span>
<span class="k">class</span> <span class="nc">ConvertConv2D</span><span class="p">(</span><span class="n">ConvertConv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.Conv2D`` to Nengo objects.&quot;&quot;&quot;</span>

    <span class="n">unsupported_args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;dilation_rate&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="p">]</span>
    <span class="n">unsupported_training_args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;kernel_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bias_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;activity_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;kernel_constraint&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bias_constraint&quot;</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="ConvertConv2D.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConv2D.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertConv3D"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConv3D">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Conv3D</span><span class="p">,)</span>
<span class="k">class</span> <span class="nc">ConvertConv3D</span><span class="p">(</span><span class="n">ConvertConv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.Conv3D`` to Nengo objects.&quot;&quot;&quot;</span>

    <span class="n">unsupported_args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;dilation_rate&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="p">]</span>
    <span class="n">unsupported_training_args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;kernel_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bias_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;activity_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;kernel_constraint&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bias_constraint&quot;</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="ConvertConv3D.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertConv3D.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertDense"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertDense">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertDense</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.Dense`` to Nengo objects.&quot;&quot;&quot;</span>

    <span class="n">unsupported_training_args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;kernel_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bias_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;activity_regularizer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;kernel_constraint&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bias_constraint&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">has_weights</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ConvertDense.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertDense.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="c1"># look up parameter values from source layer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">use_bias</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">,</span> <span class="n">biases</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">batch_get_value</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">kernel</span><span class="p">)</span>
            <span class="n">biases</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># create nengo object to implement activation function and biases</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nengo_obj</span><span class="p">(</span>
            <span class="n">node_id</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span> <span class="n">biases</span><span class="o">=</span><span class="n">biases</span>
        <span class="p">)</span>

        <span class="c1"># add connection to implement the dense weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">weights</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">trainable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="ConvertFlatten"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertFlatten">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Flatten</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertFlatten</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.Flatten`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertFlatten.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertFlatten.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="c1"># noop, same as reshape</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_input_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertInput"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertInput">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">InputLayer</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertInput</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.InputLayer`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertInput.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertInput.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="c1"># if this input layer has an input obj, that means it is a passthrough</span>
        <span class="c1"># (so we just return the input)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_input_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># not a passthrough input, so create input node</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Input shapes must be fully specified; got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>
                <span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span> <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Created </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="ConvertReLU"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertReLU">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">ReLU</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertReLU</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.ReLU`` to Nengo objects.&quot;&quot;&quot;</span>

    <span class="n">unsupported_args</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;negative_slope&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;max_value&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;threshold&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>

<div class="viewcode-block" id="ConvertReLU.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertReLU.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nengo_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">biases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="ConvertReshape"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertReshape">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Reshape</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertReshape</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.Reshape`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertReshape.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertReshape.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="c1"># nengo doesn&#39;t pass shape information between objects (everything is just a</span>
        <span class="c1"># vector), so we don&#39;t actually need to do anything here, we just return</span>
        <span class="c1"># the input layer. layers that require shape information can look it up from</span>
        <span class="c1"># the input_shape attribute of their layer</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_input_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertZeroPadding"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertZeroPadding">[docs]</a><span class="k">class</span> <span class="nc">ConvertZeroPadding</span><span class="p">(</span><span class="n">LayerConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for converting zero-padding layers to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertZeroPadding.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertZeroPadding.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nengo_obj</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

        <span class="c1"># zeropadding1d doesn&#39;t doesn&#39;t have data_format, assumes channels_last</span>
        <span class="n">channels_first</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;data_format&quot;</span><span class="p">,</span> <span class="s2">&quot;channels_last&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;channels_first&quot;</span>
        <span class="p">)</span>

        <span class="c1"># the strategy here is that we&#39;ll create a nengo node of the full padded size,</span>
        <span class="c1"># and then connect up the input to the subset of those node elements</span>
        <span class="c1"># corresponding to the inner, non-padded elements. so we need to figure out</span>
        <span class="c1"># what the indices are that we need to connect to.</span>

        <span class="c1"># build slices representing the non-padded elements within the output shape</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">channels_first</span><span class="p">:</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">top_pad</span><span class="p">,</span> <span class="n">bottom_pad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">padding</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">top_pad</span><span class="p">,</span> <span class="n">bottom_pad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">padding</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">)[</span><span class="n">i</span> <span class="o">+</span> <span class="n">channels_first</span><span class="p">]</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">top_pad</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="n">bottom_pad</span><span class="p">))</span>

        <span class="c1"># apply slices to index array to get the list of indices we want to connect to</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">size_in</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">(</span><span class="n">node_id</span><span class="p">))</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">idxs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)])</span>

        <span class="c1"># connect up the input to the appropriate indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="n">idxs</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="ConvertZeroPadding1D"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertZeroPadding1D">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">ZeroPadding1D</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertZeroPadding1D</span><span class="p">(</span><span class="n">ConvertZeroPadding</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.ZeroPadding1D`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertZeroPadding1D.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertZeroPadding1D.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertZeroPadding2D"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertZeroPadding2D">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">ZeroPadding2D</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertZeroPadding2D</span><span class="p">(</span><span class="n">ConvertZeroPadding</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.ZeroPadding2D`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertZeroPadding2D.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertZeroPadding2D.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ConvertZeroPadding3D"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertZeroPadding3D">[docs]</a><span class="nd">@Converter</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">ZeroPadding3D</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ConvertZeroPadding3D</span><span class="p">(</span><span class="n">ConvertZeroPadding</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``tf.keras.layers.ZeroPadding3D`` to Nengo objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConvertZeroPadding3D.convert"><a class="viewcode-back" href="../../reference.html#nengo_dl.ConvertZeroPadding3D.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></div></div>
</pre></div>

            </div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div><footer class="text-light footer-main gradient-bottom">
  <p class="small text-center mb-0">
    <a class="no-hover-line" href="https://appliedbrainresearch.com">
      <img
        src="https://appliedbrainresearch.com/img/logo-blue-notext.svg"
        height="48"
      />
    </a>
    <a href="https://www.nengo.ai/">What is Nengo?</a>
    <a href="https://www.nengo.ai/examples/">Examples</a>
    <a href="https://www.nengo.ai/documentation/">Documentation</a>
    <a href="https://www.nengo.ai/getting-started/">Getting started</a>
    <a href="https://www.nengo.ai/privacy/">Privacy</a>
  </p>
  <p class="small text-center mb-0">&copy; Applied Brain Research</p>
</footer>
<script>
  function switchVersion(select) {
    var option = select.selectedOptions[0];
    if (option.hasAttribute("value")) {
      window.location = option.value;
    }
  }
</script>

<script>
  var elements = document.querySelectorAll('.sidenav');
  Stickyfill.add(elements);
</script>
<script>
  ScrollReveal().reveal(".fade-in", {
      scale: 0.85,
      duration: 1000,
      delay: 250,
      interval: 50
  });
</script>
<script>
  $('a.toggle-sidenav').on('click', function(e) {
    e.preventDefault();
    if ( $(this).hasClass('active') ) {
      $(this).removeClass('active');
      $('.sidenav').removeClass('open');
    } else {
      $(this).addClass('active');
      $('.sidenav').addClass('open');
    }
  });
</script>
<script>
  var lists = document.querySelectorAll('.toctree ul');
  lists.forEach((ul) => {
      ul.classList.add("nav");
  });
  var links = document.querySelectorAll('.toctree a');
  links.forEach((link) => {
      link.classList.add("nav-link");
  });
  $("body").scrollspy({target: ".sidenav"});
</script>
  </body>
</html>